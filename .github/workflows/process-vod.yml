name: Process VOD
run-name: Process VOD ${{ inputs.vod_id }}

on:
  workflow_dispatch:
    inputs:
      vod_id:
        description: "VOD ID to process"
        required: true
        type: string
      chunk_uuids:
        description: "JSON array of chunk UUIDs to process"
        required: true
        type: string

env:
  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
  SUPABASE_SECRET_KEY: ${{ secrets.SUPABASE_SECRET_KEY }}

jobs:
  # Pre-flight check: Verify VOD availability and determine best quality
  check-vod:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      quality: ${{ steps.check.outputs.quality }}
      available: ${{ steps.check.outputs.available }}

    steps:
      - name: Install streamlink
        run: |
          pip install --upgrade streamlink
          streamlink --version

      - name: Check VOD availability and quality
        id: check
        run: |
          echo "Checking VOD ${{ inputs.vod_id }} availability and qualities..."
          VOD_URL="https://www.twitch.tv/videos/${{ inputs.vod_id }}"

          # Get available streams in JSON format
          STREAMS_JSON=$(streamlink --json "$VOD_URL" 2>/dev/null || echo '{"error": "failed"}')

          # Check if VOD is available
          if echo "$STREAMS_JSON" | grep -q '"error"'; then
            echo "VOD ${{ inputs.vod_id }} is not available"
            echo "$STREAMS_JSON"
            echo "available=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Extract available streams
          echo "Available streams JSON:"
          echo "$STREAMS_JSON" | jq '.streams | keys'

          # Determine best quality (preference: 480p -> 720p -> 1080p -> 360p -> best)
          QUALITY=""

          # Check for preferred qualities in order
          if echo "$STREAMS_JSON" | jq -e '.streams["480p"]' > /dev/null 2>&1; then
            QUALITY="480p"
          elif echo "$STREAMS_JSON" | jq -e '.streams["720p"]' > /dev/null 2>&1; then
            QUALITY="720p"
          elif echo "$STREAMS_JSON" | jq -e '.streams["720p60"]' > /dev/null 2>&1; then
            QUALITY="720p"
          elif echo "$STREAMS_JSON" | jq -e '.streams["1080p"]' > /dev/null 2>&1; then
            QUALITY="1080p"
          elif echo "$STREAMS_JSON" | jq -e '.streams["1080p60"]' > /dev/null 2>&1; then
            QUALITY="1080p"
          else
            QUALITY="1080p"

          fi

          echo "Selected quality: $QUALITY"
          echo "quality=$QUALITY" >> $GITHUB_OUTPUT
          echo "available=true" >> $GITHUB_OUTPUT

      - name: Update VOD status to failed if not available
        if: failure()
        run: |
          echo "Updating VOD ${{ inputs.vod_id }} status to 'failed' - VOD not available"

          # Update VOD status to failed and availability to unavailable
          curl -X PATCH "$SUPABASE_URL/rest/v1/vods?source_id=eq.${{ inputs.vod_id }}" \
            -H "apikey: $SUPABASE_SECRET_KEY" \
            -H "Authorization: Bearer $SUPABASE_SECRET_KEY" \
            -H "Content-Type: application/json" \
            -H "Prefer: return=minimal" \
            -d '{"status": "failed", "availability": "unavailable", "last_error": "VOD not available on Twitch"}'

          echo "VOD marked as failed and unavailable"

  # Process all chunks in parallel using matrix strategy
  process-chunk:
    needs: check-vod
    runs-on: ubuntu-latest
    timeout-minutes: 30 # Overall job timeout
    strategy:
      matrix:
        chunk_id: ${{ fromJson(inputs.chunk_uuids) }}
      # Allow some chunks to fail without stopping others
      fail-fast: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        timeout-minutes: 5

      - name: Build SFOT container with cache
        uses: docker/build-push-action@v5
        timeout-minutes: 10
        with:
          context: ./sfot
          tags: bazaar-ghost-sfot
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Process chunk with SFOT
        id: sfot
        timeout-minutes: 25
        run: |
          # Create output directory
          mkdir -p ./output

          echo "Processing chunk ${{ matrix.chunk_id }} for VOD ${{ inputs.vod_id }}"
          echo "Using quality: ${{ needs.check-vod.outputs.quality }}"

          # Run SFOT container - it will handle all chunk details and status updates internally
          docker run --rm \
            --network="host" \
            -v "./output:/app/output" \
            -e SUPABASE_URL="$SUPABASE_URL" \
            -e SUPABASE_SECRET_KEY="$SUPABASE_SECRET_KEY" \
            -e CHUNK_ID="${{ matrix.chunk_id }}" \
            -e TEST_MODE="false" \
            -e QUALITY="${{ needs.check-vod.outputs.quality }}" \
            bazaar-ghost-sfot

          DOCKER_EXIT_CODE=$?
          echo "Docker run exit code: $DOCKER_EXIT_CODE"

          if [ $DOCKER_EXIT_CODE -eq 0 ]; then
            echo "Chunk ${{ matrix.chunk_id }} completed successfully"
          else
            echo "Chunk ${{ matrix.chunk_id }} failed with exit code: $DOCKER_EXIT_CODE"
            exit $DOCKER_EXIT_CODE
          fi

      - name: Update VOD status to failed
        if: failure()
        run: |
          echo "Updating VOD ${{ inputs.vod_id }} status to 'failed' due to chunk processing failure"

          # Update VOD status to failed using Supabase API
          curl -X PATCH "$SUPABASE_URL/rest/v1/vods?source_id=eq.${{ inputs.vod_id }}" \
            -H "apikey: $SUPABASE_SECRET_KEY" \
            -H "Authorization: Bearer $SUPABASE_SECRET_KEY" \
            -H "Content-Type: application/json" \
            -H "Prefer: return=minimal" \
            -d '{"status": "failed", "last_error": "Chunk processing failed in GitHub Actions"}'

          echo "VOD status updated to failed"
